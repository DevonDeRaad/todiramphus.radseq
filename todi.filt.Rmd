---
title: "Todiramphus data filtering"
author: "Devon DeRaad"
date: "10/2/2021"
output: html_document
---

```{r, results='hide', message=FALSE}
#load packages
library(vcfR)
library(ggplot2)
library(adegenet)
library(SNPfiltR)
library(StAMPP)

#read in vcf as vcfR
#this has been pre-filtered using the command:
#vcftools --vcf populations.snps.vcf --out filt --max-missing .1 --recode --recode-INFO-all
#in order to make sure that the file can be read into Rstudio
vcfR <- read.vcfR("~/Desktop/todi.2022/populations.snps.vcf")
### check the metadata present in your vcf
vcfR

#read in sample info csv
sample.info<-read.csv("~/Desktop/todi.2022/todiramphus.subset.csv")

#make sure sampling file matches vcf
sample.info$id %in% colnames(vcfR@gt)[-1]
colnames(vcfR@gt)[-1] %in% sample.info$id

#if needed, subset sampling file to include only samples in vcf
#sample.info<-sample.info[sample.info$id %in% colnames(vcfR@gt)[-1],]

#reorder sampling file to match order of samples in vcf
sample.info<-sample.info[match(colnames(vcfR@gt)[-1], sample.info$id),]
sample.info$id == colnames(vcfR@gt)[-1]
```

### step 1: Implement quality filters that don't involve missing data. This is because removing low data samples will alter percentage/quantile based missing data cutoffs, so we wait to implement those until after deciding on our final set of samples for downstream analysis

```{r}
#hard filter to minimum depth of 5, and minimum genotype quality of 30
vcfR<-hard_filter(vcfR=vcfR, depth = 5, gq = 30)
```

### Use this function to filter for allele balance from Puritz SNP filtering tutorial "Allele balance: a number between 0 and 1 representing the ratio of reads showing the reference allele to all reads, considering only reads from individuals called as heterozygous, we expect that the allele balance in our data (for real loci) should be close to 0.5"

```{r}
#execute allele balance filter
vcfR<-filter_allele_balance(vcfR)
```

### max depth filter (super high depth loci are likely multiple loci stuck together into a single paralogous locus).

```{r}
#visualize and pick appropriate max depth cutoff
max_depth(vcfR)

#filter vcf by the max depth cutoff you chose
vcfR<-max_depth(vcfR, maxdepth = 100)

#check vcfR to see how many SNPs we have left
vcfR
```

### Step 2: visualize missing data by sample. Check out the visualizations and make decision on which samples to keep for downstream analysis.

```{r}
#run function to visualize samples
miss<-missing_by_sample(vcfR=vcfR)

#histogram of number of SNPs called in each sample at a .5 SNP completeness cutoff
hist(miss$snps.retained[miss$filt == .5], breaks=50)
hist(miss$snps.retained[miss$filt == .5], breaks = 100)

#run function to drop samples above the threshold we want from the vcf
#(going with a very lenient cutoff here, can clean up bad samples down the line if needed)
vcfR<-missing_by_sample(vcfR=vcfR, cutoff = .95)
#remove invariant sites generated by sample trimming
vcfR<-min_mac(vcfR, min.mac = 1)
```
### interrogate potential batch effects between runs

```{r}
#interrogate batch effects between runs
#make a popmap where pop corresponds to the run the sample was on
batch.map<-sample.info[sample.info$id %in% colnames(vcfR@gt)[-1],c(1,2)]
colnames(batch.map)<-c("id","pop")
batch.map$pop<-as.factor(batch.map$pop)
#
assess_missing_data_pca(vcfR, popmap=batch.map, thresholds = .8, clustering = FALSE)

#samples are clustering as species and within species by missing data, no indication of batch effects here
```

### Step 3: Set the arbitrary missing data cutoff
### We can visualize the effect that typical missing data cutoffs will have on both the number of SNPs retained and the total missing data in our entire dataset. We want to choose a cutoff that minimizes the overall missing data in the dataset, while maximizing the total number of loci retained.
```{r}
#visualize missing data by SNP and the effect of various cutoffs on the missingness of each sample
missing_by_snp(vcfR)

#still need to target specific samples with too much missing data even at high filtering thresholds, for removal
#rerun missing by sample
miss<-missing_by_sample(vcfR=vcfR)
#show me the samples with the most missing data at a 85% completeness threshold
filt<-miss[miss$filt == .8,]
filt[order(filt$snps.retained),]

#drop the three continuing outlier samples at a 85% SNP completeness threshold
vcfR<- vcfR[,colnames(vcfR@gt) != "T_chloris_67535_run1" &
             colnames(vcfR@gt) != "T_chloris_23631" &
             colnames(vcfR@gt) != "T_sanctus_76296" &
             colnames(vcfR@gt) != "T_sanctus_B52989"]
#remove invariant SNPs
vcfR<-min_mac(vcfR, min.mac = 1)
vcfR

#re-visualize missing data by SNP and the effect of various cutoffs on the missingness of each sample
missing_by_snp(vcfR)
#all samples look decent at high thresholds

#make popmap
popmap<-sample.info[sample.info$id %in% colnames(vcfR@gt)[-1],c(1,5)]
colnames(popmap)<-c("id","pop")
popmap$pop<-as.factor(popmap$pop)

#assess missing data effects on clustering
assess_missing_data_pca(vcfR = vcfR, popmap = popmap, thresholds = c(.75,.8,.85), clustering = FALSE)

```

### evaluate the effect of missing data using splitstree

```{r}
#set two potential cutoffs
vcfRa<-missing_by_snp(vcfR, cutoff = .8)
vcfRb<-missing_by_snp(vcfR, cutoff = .85)
#convert each to genlight
gena<-vcfR2genlight(vcfRa)
genb<-vcfR2genlight(vcfRb)

#output pairwise difference matrix for each to run splitstree
gena@ind.names<-gsub(gena@ind.names, pattern = "T_", replacement = "")
gena@ind.names<-gsub(gena@ind.names, pattern = "_", replacement = "")
gena@ind.names<-gsub(gena@ind.names, pattern = "albicilla", replacement = "alb")
gena@ind.names<-gsub(gena@ind.names, pattern = "chloris", replacement = "chlor")
gena@ind.names<-gsub(gena@ind.names, pattern = "colonus", replacement = "col")
gena@ind.names<-gsub(gena@ind.names, pattern = "sanctus", replacement = "san")
gena@ind.names<-gsub(gena@ind.names, pattern = "saurophagus", replacement = "saur")
gena@ind.names<-gsub(gena@ind.names, pattern = "sordidus", replacement = "sord")
gena@ind.names<-gsub(gena@ind.names, pattern = "tristrami", replacement = "tris")
gena@ind.names<-gsub(gena@ind.names, pattern = "leucopygius", replacement = "leu")
gena@ind.names<-gsub(gena@ind.names, pattern = "DOT", replacement = "D")
gena@ind.names

pop(gena)<-popmap$pop
sample.div.80 <- stamppNeisD(gena, pop = FALSE)
#export for splitstree
#stamppPhylip(distance.mat=sample.div.80, file="~/Desktop/todi.2022/todi.80.splits.txt")

#80% completeness cutoff splitstree
knitr::include_graphics(c("/Users/devder/Desktop/todi.2022/todi.80.splitstree.png"))

#repeat for 85% cutoff
#output pairwise difference matrix for each to run splitstree
genb@ind.names<-gena@ind.names
pop(genb)<-popmap$pop
sample.div.85 <- stamppNeisD(genb, pop = FALSE)
#export for splitstree
#stamppPhylip(distance.mat=sample.div.85, file="~/Desktop/todi.2022/todi.85.splits.txt") 

#85% completeness cutoff splitstree
knitr::include_graphics(c("/Users/devder/Desktop/todi.2022/todi.85.splitstree.png"))

#repeat with removing singletons
vcfR.mac<-min_mac(vcfRa, min.mac = 2)
genc<-vcfR2genlight(vcfR.mac)
genc@ind.names<-gena@ind.names
pop(genc)<-popmap$pop
sample.div <- stamppNeisD(genc, pop = FALSE)
#export for splitstree
#stamppPhylip(distance.mat=sample.div, file="~/Desktop/todi.2022/todi.80.min.mac.splits.txt") 

#80% completeness cutoff with min.mac splitstree
knitr::include_graphics(c("/Users/devder/Desktop/todi.2022/todi.80.mac.splitstree.png"))


#the three splitstrees are nearly identical. I am satisfied that neither missing data nor singletons are driving patterns of sample relatedness/assignment. We will keep the 85% complete dataset without a minor allele filter for downstream analyses because it looks the cleanest.

```


```{r}
#plot depth per snp and per sample
dp <- extract.gt(vcfRa, element = "DP", as.numeric=TRUE)
heatmap.bp(dp, rlabels = FALSE)
```

```{r}
#plot genotype quality per snp and per sample
gq <- extract.gt(vcfRa, element = "GQ", as.numeric=TRUE)
heatmap.bp(gq, rlabels = FALSE)
```

###We can use the convenient function 'write.vcf' from vcfR to export our filtered vcf file for downstream analyses

```{r}
#write out vcf
vcfR::write.vcf(vcfRb, file = "~/Desktop/todi.2022/todi.85.vcf.gz")
#perform linkage filtering to get a reduced vcf with only unlinked SNPs
vcfR.thin<-distance_thin(vcfRb, min.distance = 100)
vcfR.thin
vcfR::write.vcf(vcfR.thin, file = "~/Desktop/todi.2022/todi.unlinked.85.vcf.gz")
```


